'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var build_1 = require("./utils/build");
var formatMessages_1 = require("./utils/formatMessages");
var validateAttributes_1 = __importDefault(require("./validators/validateAttributes"));
var validationRuleParser_1 = __importDefault(require("./validators/validationRuleParser"));
var general_1 = require("./utils/general");
var object_1 = require("./utils/object");
var errorBag_1 = __importDefault(require("./validators/errorBag"));
var ruleContract_1 = __importDefault(require("./rules/ruleContract"));
var lang_1 = __importDefault(require("./lang"));
var password_1 = __importDefault(require("./rules/password"));
var validationData_1 = __importDefault(require("./validators/validationData"));
var Validator = /** @class */ (function () {
    function Validator(data, rules, customMessages) {
        if (customMessages === void 0) { customMessages = {}; }
        this.data = data;
        this.customMessages = customMessages;
        this.initalRules = rules;
        this.lang = lang_1.default.getDefaultLang();
        this.addRules(rules);
        this.messages = new errorBag_1.default();
    }
    ;
    Validator.prototype.setData = function (data) {
        this.data = data;
        this.addRules(this.initalRules);
        return this;
    };
    ;
    Validator.prototype.setRules = function (rules) {
        this.addRules(rules);
        this.initalRules = rules;
        return this;
    };
    ;
    Validator.prototype.setLang = function (lang) {
        this.lang = lang;
        return this;
    };
    ;
    Validator.prototype.setCustomMessages = function (customMessages) {
        if (customMessages === void 0) { customMessages = {}; }
        this.customMessages = customMessages;
        return this;
    };
    ;
    Validator.prototype.stopOnFirstFailure = function (stopOnFirstFailure) {
        if (stopOnFirstFailure === void 0) { stopOnFirstFailure = true; }
        this.stopOnFirstFailureFlag = stopOnFirstFailure;
        return this;
    };
    ;
    Validator.prototype.errors = function () {
        return this.messages;
    };
    ;
    Validator.prototype.validate = function () {
        if (!(0, object_1.isObject)(this.data)) {
            throw 'The data attribute must be an object';
        }
        this.messages = new errorBag_1.default();
        this.validateAttributes = new validateAttributes_1.default(this.data, this.rules);
        for (var property in this.rules) {
            if (this.rules.hasOwnProperty(property) && Array.isArray(this.rules[property])) {
                for (var i = 0; i < this.rules[property].length; i++) {
                    this.validateAttribute(property, this.rules[property][i]);
                    if (this.messages.keys().length > 0 && this.stopOnFirstFailureFlag === true) {
                        return false;
                    }
                    if (this.shouldStopValidating(property)) {
                        break;
                    }
                }
            }
        }
        return this.messages.keys().length === 0;
    };
    ;
    Validator.prototype.shouldStopValidating = function (attribute) {
        return this.messages.has(attribute) && validationRuleParser_1.default.hasRule(attribute, ['bail'], this.rules);
    };
    ;
    /**
     * Parse the given rules add assign them to the current rules
     */
    Validator.prototype.addRules = function (rules) {
        // The primary purpose of this parser is to expand any "*" rules to the all
        // of the explicit rules needed for the given data. For example the rule
        // names.* would get expanded to names.0, names.1, etc. for this data.
        var response = validationRuleParser_1.default.explodeRules((0, object_1.dotify)(rules, true), this.data);
        this.rules = response.rules;
        this.implicitAttributes = response.implicitAttributes;
    };
    ;
    /**
     * validate a given attribute against a rule.
     */
    Validator.prototype.validateAttribute = function (attribute, rule) {
        var _a;
        var parameters = [];
        _a = validationRuleParser_1.default.parse(rule), rule = _a[0], parameters = _a[1];
        var keys = this.getExplicitKeys(attribute);
        if (keys.length > 0 && parameters.length > 0) {
            parameters = this.replaceAsterisksInParameters(parameters, keys);
        }
        var value = (0, object_1.deepFind)(this.data, attribute);
        var validatable = this.isValidatable(attribute, value, rule);
        if (rule instanceof ruleContract_1.default) {
            return validatable ? this.validateUsingCustomRule(attribute, value, rule) : null;
        }
        var method = "validate".concat((0, build_1.builValidationdMethodName)(rule));
        if (rule !== '' && typeof this.validateAttributes[method] === 'undefined') {
            throw "Rule ".concat(rule, " is not valid");
        }
        if (validatable &&
            !this.validateAttributes[method](value, parameters, attribute)) {
            this.addFailure(attribute, rule, value, parameters);
        }
    };
    ;
    Validator.prototype.validateUsingCustomRule = function (attribute, value, rule) {
        rule.setData(this.data).setLang(this.lang);
        if (rule instanceof password_1.default) {
            rule.setValidator(this);
        }
        if (rule.passes(value, attribute)) {
            return;
        }
        var result = rule.getMessage();
        var messages = typeof result === 'string' ? [result] : result;
        for (var key in messages) {
            this.messages.add(attribute, {
                error_type: rule.constructor.name, message: (0, formatMessages_1.makeReplacements)(messages[key], attribute, rule.constructor.name, [])
            });
        }
    };
    ;
    /**
     * Add a new error message to the messages object
     */
    Validator.prototype.addFailure = function (attribute, rule, value, parameters) {
        var hasNumericRule = validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules);
        var message = (0, formatMessages_1.makeReplacements)((0, formatMessages_1.getMessage)(attribute, rule, value, this.customMessages, hasNumericRule, this.lang), attribute, rule, parameters, this.data, hasNumericRule);
        var error = {
            error_type: rule,
            message: message
        };
        this.messages.add(attribute, error);
    };
    ;
    /**
     * Replace each field parameter which has asterisks with the given keys.
     *
     * Example: parameters = [name.*.first] and keys = [1], then the result will be name.1.first
     */
    Validator.prototype.replaceAsterisksInParameters = function (parameters, keys) {
        return parameters.map(function (parameter) {
            var result = '';
            if (parameter.indexOf('*') !== -1) {
                var parameterArray = parameter.split('*');
                result = parameterArray[0];
                for (var i = 1; i < parameterArray.length; i++) {
                    result = result.concat((keys[i - 1] || '*') + parameterArray[i]);
                }
            }
            return result || parameter;
        });
    };
    ;
    /**
     * Determine if the attribute is validatable.
     */
    Validator.prototype.isValidatable = function (attribute, value, rule) {
        return this.presentOrRuleIsImplicit(attribute, value, rule) &&
            this.passesOptionalCheck(attribute) &&
            this.isNotNullIfMarkedAsNullable(attribute, rule);
    };
    ;
    /**
     * Determine if the field is present, or the rule implies required.
     */
    Validator.prototype.presentOrRuleIsImplicit = function (attribute, value, rule) {
        if (typeof value === 'string' && value.trim() === '') {
            return (0, general_1.isImplicitRule)(rule);
        }
        return typeof (0, object_1.deepFind)(this.data, attribute) !== 'undefined' ||
            (0, general_1.isImplicitRule)(rule);
    };
    /**
     * Determine if the attribute passes any optional check.
     */
    Validator.prototype.passesOptionalCheck = function (attribute) {
        if (!validationRuleParser_1.default.hasRule(attribute, ['sometimes'], this.rules)) {
            return true;
        }
        var data = validationData_1.default.initializeAndGatherData(attribute, this.data);
        return data.hasOwnProperty(attribute)
            || this.data.hasOwnProperty(attribute);
    };
    ;
    /**
     * Determine if the attribute fails the nullable check.
     */
    Validator.prototype.isNotNullIfMarkedAsNullable = function (attribute, rule) {
        if ((0, general_1.isImplicitRule)(rule) || !validationRuleParser_1.default.hasRule(attribute, ['nullable'], this.rules)) {
            return true;
        }
        return (0, object_1.deepFind)(this.data, attribute) !== null;
    };
    ;
    /**
     * Get the primary attribute name
     *
     * Example:  if "name.0" is given, "name.*" will be returned
     */
    Validator.prototype.getPrimaryAttribute = function (attribute) {
        for (var unparsed in this.implicitAttributes) {
            if (this.implicitAttributes[unparsed].indexOf(attribute) !== -1) {
                return unparsed;
            }
        }
        return attribute;
    };
    ;
    /**
     * Get the explicit keys from an attribute flattened with dot notation.
     *
     * Example: 'foo.1.bar.spark.baz' -> [1, 'spark'] for 'foo.*.bar.*.baz'
     */
    Validator.prototype.getExplicitKeys = function (attribute) {
        var pattern = new RegExp('^' + this.getPrimaryAttribute(attribute).replace(/\*/g, '([^\.]*)'));
        var keys = attribute.match(pattern);
        if (keys) {
            keys.shift();
            return keys;
        }
        return [];
    };
    ;
    return Validator;
}());
exports.default = Validator;

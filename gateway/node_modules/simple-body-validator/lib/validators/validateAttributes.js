'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var date_1 = require("../utils/date");
var object_1 = require("../utils/object");
var general_1 = require("../utils/general");
var validationRuleParser_1 = __importDefault(require("./validationRuleParser"));
var validateAttributes = /** @class */ (function () {
    function validateAttributes(data, rules) {
        if (data === void 0) { data = {}; }
        if (rules === void 0) { rules = {}; }
        this.data = data;
        this.rules = rules;
    }
    ;
    /**
     * Validate that an attribute was "accepted".
     *
     * This validation rule implies the attribute is "required".
     */
    validateAttributes.prototype.validateAccepted = function (value) {
        var acceptable = ['yes', 'on', '1', 1, true, 'true'];
        return this.validateRequired(value) && acceptable.indexOf(value) !== -1;
    };
    /**
     * Validate that an attribute was "accepted" when another attribute has a given value.
     */
    validateAttributes.prototype.validateAcceptedIf = function (value, parameters) {
        this.requireParameterCount(2, parameters, 'accepted_if');
        var other = (0, object_1.deepFind)(this.data, parameters[0]);
        if (!other) {
            return true;
        }
        var values = parameters.slice(1);
        if (values.indexOf(other) !== -1) {
            return this.validateAccepted(value);
        }
        return true;
    };
    /**
     *  Validate the date is after a given date.
     */
    validateAttributes.prototype.validateAfter = function (value, parameters) {
        this.requireParameterCount(1, parameters, 'after');
        return this.compareDates(value, parameters[0], '>', 'after');
    };
    ;
    /**
     * Validate the date is after or equal a given date.
     */
    validateAttributes.prototype.validateAfterOrEqual = function (value, parameters) {
        this.requireParameterCount(1, parameters, 'after_or_equal');
        return this.compareDates(value, parameters[0], '>=', 'after_or_equal');
    };
    ;
    /**
     * Validate that an attribute contains only alphabetic characters.
     */
    validateAttributes.prototype.validateAlpha = function (value) {
        var regex = /^[a-zA-Z]+$/;
        return typeof value === 'string' && regex.test(value);
    };
    ;
    /**
     * Validate that an attribute contains only alpha-numeric characters, dashes, and underscores.
     */
    validateAttributes.prototype.validateAlphaDash = function (value) {
        if (typeof value != 'string' && typeof value != 'number') {
            return false;
        }
        var regex = /^[a-zA-Z0-9-_]+$/;
        return regex.test(value.toString());
    };
    ;
    /**
     * Validate that an attribute contains only alpha-numeric characters.
     */
    validateAttributes.prototype.validateAlphaNum = function (value) {
        if (typeof value != 'string' && typeof value != 'number') {
            return false;
        }
        var regex = /^[a-zA-Z0-9]+$/;
        return regex.test(value.toString());
    };
    /**
     * Validate that an attribute is an array
     */
    validateAttributes.prototype.validateArray = function (value) {
        return Array.isArray(value);
    };
    ;
    /**
     * Always returns true - this method will be used in conbination with other rules and will be used to stop validation of first failure
     */
    validateAttributes.prototype.validateBail = function () {
        return true;
    };
    ;
    /**
     *  Validate the date is before a given date.
     */
    validateAttributes.prototype.validateBefore = function (value, parameters) {
        this.requireParameterCount(1, parameters, 'before');
        return this.compareDates(value, parameters[0], '<', 'before');
    };
    /**
     * Validate the date is before or equal a given date.
     */
    validateAttributes.prototype.validateBeforeOrEqual = function (value, parameters) {
        this.requireParameterCount(1, parameters, 'before_or_equal');
        return this.compareDates(value, parameters[0], '<=', 'before_or_equal');
    };
    /**
     * Validate the size of an attribute is between a set of values
     */
    validateAttributes.prototype.validateBetween = function (value, parameters, attribute) {
        if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'object') {
            throw 'Validation rule between requires the field under validation to be a number, string, array, or object.';
        }
        this.requireParameterCount(2, parameters, 'between');
        var min = parameters[0], max = parameters[1];
        if (isNaN(min) || isNaN(max)) {
            throw 'Validation rule between requires both parameters to be numbers.';
        }
        min = Number(min);
        max = Number(max);
        if (min >= max) {
            throw 'Validation rule between requires that the first parameter be greater than the second one.';
        }
        var size = (0, general_1.getSize)(value, validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules));
        return size >= min && size <= max;
    };
    ;
    /**
     * Validate that an attribute is boolean
     */
    validateAttributes.prototype.validateBoolean = function (value, parameters, attribute) {
        if (validationRuleParser_1.default.hasRule(attribute, 'strict', this.rules)) {
            return typeof value === 'boolean';
        }
        var acceptable = [true, false, 0, 1, '0', '1'];
        return acceptable.indexOf(value) !== -1;
    };
    ;
    /**
     * Validate that an attribute has matching confirmation.
     */
    validateAttributes.prototype.validateConfirmed = function (value, parameters, attribute) {
        return this.validateSame(value, ["".concat(attribute, "_confirmation")]);
    };
    ;
    /**
     * Validate that an attribute is a valid date.
     */
    validateAttributes.prototype.validateDate = function (value) {
        return (0, date_1.toDate)(value) ? true : false;
    };
    ;
    /**
     * Validate that an attribute is equal to another date.
     */
    validateAttributes.prototype.validateDateEquals = function (value, paramters) {
        this.requireParameterCount(1, paramters, 'date_equals');
        return this.compareDates(value, paramters[0], '=', 'date_equals');
    };
    ;
    /**
     * Validate that an attribute was "declined".
     *
     * This validation rule implies the attribute is "required".
     */
    validateAttributes.prototype.validateDeclined = function (value) {
        var acceptable = ['no', 'off', '0', 0, false, 'false'];
        return this.validateRequired(value) && acceptable.indexOf(value) !== -1;
    };
    ;
    /**
     * Validate that an attribute was "declined" when another attribute has a given value.
     */
    validateAttributes.prototype.validateDeclinedIf = function (value, parameters) {
        this.requireParameterCount(2, parameters, 'declined_if');
        var other = (0, object_1.deepFind)(this.data, parameters[0]);
        if (!other) {
            return true;
        }
        var values = parameters.slice(1);
        if (values.indexOf(other) !== -1) {
            return this.validateDeclined(value);
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute is different from another attribute.
     */
    validateAttributes.prototype.validateDifferent = function (value, parameters) {
        this.requireParameterCount(1, parameters, 'different');
        var other = (0, object_1.deepFind)(this.data, parameters[0]);
        return value !== other;
    };
    ;
    /**
     *  Validate that an attribute has a given number of digits.
     */
    validateAttributes.prototype.validateDigits = function (value, parameters) {
        this.requireParameterCount(1, parameters, 'digits');
        if ((0, general_1.isInteger)(parameters[0]) === false) {
            throw 'Validation rule digits requires the parameter to be an integer.';
        }
        if (parameters[0] <= 0) {
            throw 'Validation rule digits requires the parameter to be an integer greater than 0.';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            return false;
        }
        value = value.toString();
        return /^\d+$/.test(value) && value.length === parseInt(parameters[0]);
    };
    ;
    /**
     * Validate that an attribute is between a given number of digits.
     */
    validateAttributes.prototype.validateDigitsBetween = function (value, parameters) {
        this.requireParameterCount(2, parameters, 'digits_between');
        var min = parameters[0], max = parameters[1];
        if ((0, general_1.isInteger)(min) === false || (0, general_1.isInteger)(max) === false) {
            throw 'Validation rule digits_between requires both parameters to be integers.';
        }
        min = parseInt(min);
        max = parseInt(max);
        if (min <= 0 || max <= 0) {
            throw 'Validation rule digits_between requires the parameters to be an integer greater than 0.';
        }
        if (min >= max) {
            throw 'Validation rule digits_between requires the max param to be greater than the min param.';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            return false;
        }
        value = value.toString();
        var valueLength = value.length;
        return /^\d+$/.test(value) && valueLength >= min && valueLength <= max;
    };
    ;
    /**
     * Validate that an attribute is a valid email address.
     */
    validateAttributes.prototype.validateEmail = function (value) {
        if (typeof value !== 'string') {
            return false;
        }
        return value.toLowerCase().match(/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/) !== null;
    };
    ;
    /**
     * Validate the attribute ends with a given substring.
     */
    validateAttributes.prototype.validateEndsWith = function (value, parameters) {
        this.requireParameterCount(1, parameters, 'ends_with');
        if (typeof value !== 'string') {
            throw 'The field under validation must be a string';
        }
        var valueLength = value.length;
        for (var i = 0; i < parameters.length; i++) {
            if (typeof parameters[i] === 'string' && value.indexOf(parameters[i], valueLength - parameters[i].length) !== -1) {
                return true;
            }
        }
        return false;
    };
    ;
    /**
     * Validate that two attributes match.
     */
    validateAttributes.prototype.validateSame = function (value, paramaters) {
        this.requireParameterCount(1, paramaters, 'same');
        var other = (0, object_1.deepFind)(this.data, paramaters[0]);
        return value === other;
    };
    ;
    /**
     * Validate the size of an attribute.
     */
    validateAttributes.prototype.validateSize = function (value, parameters, attribute) {
        this.requireParameterCount(1, parameters, 'size');
        return (0, general_1.getSize)(value, validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules)) === Number(parameters[0]);
    };
    ;
    /**
     * Validate Optinial attributes. Always return true, just lets us put sometimes in rule.
     */
    validateAttributes.prototype.validateSometimes = function () {
        return true;
    };
    ;
    /**
     * Validate the attribute starts with a given substring.
     */
    validateAttributes.prototype.validateStartsWith = function (value, parameters) {
        this.requireParameterCount(1, parameters, 'starts_with');
        if (typeof value !== 'string') {
            throw 'The field under validation must be a string';
        }
        for (var i = 0; i < parameters.length; i++) {
            if (typeof parameters[i] === 'string' && value.substr(0, parameters[i].length) === parameters[i]) {
                return true;
            }
        }
        return false;
    };
    ;
    /**
     * Validate that a required attribute exists
     */
    validateAttributes.prototype.validateRequired = function (value) {
        if (value === null || typeof value === 'undefined') {
            return false;
        }
        else if (typeof value === 'string' && value.trim() === '') {
            return false;
        }
        else if (Array.isArray(value) && value.length < 1) {
            return false;
        }
        else if (typeof value === 'object' && Object.keys(value).length < 1) {
            return false;
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute exists when another atteribute has a given value
     */
    validateAttributes.prototype.validateRequiredIf = function (value, parameters) {
        this.requireParameterCount(2, parameters, 'required_if');
        var other = (0, object_1.deepFind)(this.data, parameters[0]);
        if (!other) {
            return true;
        }
        var values = parameters.slice(1);
        if (values.indexOf(other) !== -1) {
            return this.validateRequired(value);
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute exists when another attribute does not have a given value.
     */
    validateAttributes.prototype.validateRequiredUnless = function (value, parameters) {
        this.requireParameterCount(2, parameters, 'required_unless');
        var other = (0, object_1.deepFind)(this.data, parameters[0]);
        if (!other) {
            return true;
        }
        var values = parameters.slice(1);
        if (values.indexOf(other) === -1) {
            return this.validateRequired(value);
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute exists when any other attribute exists.
     */
    validateAttributes.prototype.validateRequiredWith = function (value, parameters) {
        if (!this.allFailingRequired(parameters)) {
            return this.validateRequired(value);
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute exists when all other attributes exist.
     */
    validateAttributes.prototype.validateRequiredWithAll = function (value, parameters) {
        if (!this.anyFailingRequired(parameters)) {
            return this.validateRequired(value);
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute exists when another attribute does not.
     */
    validateAttributes.prototype.validateRequiredWithout = function (value, parameters) {
        if (this.anyFailingRequired(parameters)) {
            return this.validateRequired(value);
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute exists when all other attributes do not.
     */
    validateAttributes.prototype.validateRequiredWithoutAll = function (value, parameters) {
        if (this.allFailingRequired(parameters)) {
            return this.validateRequired(value);
        }
        return true;
    };
    ;
    /**
     * Determine if any of the given attributes fail the required test.
     */
    validateAttributes.prototype.anyFailingRequired = function (attributes) {
        for (var i = 0; i < attributes.length; i++) {
            if (!this.validateRequired((0, object_1.deepFind)(this.data, attributes[i]))) {
                return true;
            }
        }
        return false;
    };
    ;
    /**
     * Determine if all of the given attributes fail the required test.
     */
    validateAttributes.prototype.allFailingRequired = function (attributes) {
        for (var i = 0; i < attributes.length; i++) {
            if (this.validateRequired((0, object_1.deepFind)(this.data, attributes[i]))) {
                return false;
            }
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute is a string.
     */
    validateAttributes.prototype.validateString = function (value) {
        return typeof value === 'string';
    };
    ;
    /**
    * Validate the size of an attribute is less than a maximum value.
    */
    validateAttributes.prototype.validateMax = function (value, parameters, attribute) {
        this.requireParameterCount(1, parameters, 'max');
        if (isNaN(parameters[0])) {
            throw 'Validation rule max requires parameter to be a number.';
        }
        var size = (0, general_1.getSize)(value, validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules));
        return size <= Number(parameters[0]);
    };
    ;
    /**
     * Validate the size of an attribute is greater than a minimum value.
     */
    validateAttributes.prototype.validateMin = function (value, parameters, attribute) {
        this.requireParameterCount(1, parameters, 'min');
        if (isNaN(parameters[0])) {
            throw 'Validation rule min requires parameter to be a number.';
        }
        var size = (0, general_1.getSize)(value, validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules));
        return size >= Number(parameters[0]);
    };
    ;
    /**
     * Validate that an attribute is numeric.
     */
    validateAttributes.prototype.validateNumeric = function (value, parameters, attribute) {
        if (validationRuleParser_1.default.hasRule(attribute, 'strict', this.rules) && typeof value !== 'number') {
            return false;
        }
        return isNaN(value) === false;
    };
    ;
    /**
     * Validate that an attribute is an object
     */
    validateAttributes.prototype.validateObject = function (value) {
        return (0, object_1.isObject)(value);
    };
    ;
    /**
     * Validate that an attribute exists even if not filled.
     */
    validateAttributes.prototype.validatePresent = function (value, parameters, attribute) {
        return typeof (0, object_1.deepFind)(this.data, attribute) !== 'undefined';
    };
    ;
    /**
     * Validate that an attribute is an integer.
     */
    validateAttributes.prototype.validateInteger = function (value, parameters, attribute) {
        if (validationRuleParser_1.default.hasRule(attribute, 'strict', this.rules) && typeof value !== 'number') {
            return false;
        }
        return (0, general_1.isInteger)(value);
    };
    ;
    /**
     * Validate that the attribute is a valid JSON string
     */
    validateAttributes.prototype.validateJson = function (value) {
        try {
            JSON.parse(value);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    ;
    /**
     * Validate that an attribute is greater than another attribute.
     */
    validateAttributes.prototype.validateGt = function (value, parameters, attribute) {
        this.requireParameterCount(1, parameters, 'gt');
        if (typeof value !== 'number' && typeof value !== 'string' && typeof value !== 'object') {
            throw 'The field under validation must be a number, string, array or object';
        }
        var compartedToValue = (0, object_1.deepFind)(this.data, parameters[0]) || parameters[0];
        if (!Array.isArray(compartedToValue) && isNaN(compartedToValue) === false) {
            return (0, general_1.getSize)(value, validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules)) > compartedToValue;
        }
        if ((0, general_1.sameType)(value, compartedToValue) === false) {
            throw 'The fields under validation must be of the same type';
        }
        return (0, general_1.getSize)(value) > (0, general_1.getSize)(compartedToValue);
    };
    ;
    /**
     * Validate that an attribute is greater than or equal  another attribute.
     */
    validateAttributes.prototype.validateGte = function (value, parameters, attribute) {
        this.requireParameterCount(1, parameters, 'gte');
        if (typeof value !== 'number' && typeof value !== 'string' && typeof value !== 'object') {
            throw 'The field under validation must be a number, string, array or object';
        }
        var compartedToValue = (0, object_1.deepFind)(this.data, parameters[0]) || parameters[0];
        if (!Array.isArray(compartedToValue) && isNaN(compartedToValue) === false) {
            return (0, general_1.getSize)(value, validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules)) >= compartedToValue;
        }
        if ((0, general_1.sameType)(value, compartedToValue) === false) {
            throw 'The fields under validation must be of the same type';
        }
        return (0, general_1.getSize)(value) >= (0, general_1.getSize)(compartedToValue);
    };
    ;
    /**
     * Validate that an attribute is less than another attribute.
     */
    validateAttributes.prototype.validateLt = function (value, parameters, attribute) {
        this.requireParameterCount(1, parameters, 'lt');
        if (typeof value !== 'number' && typeof value !== 'string' && typeof value !== 'object') {
            throw 'The field under validation must be a number, string, array or object';
        }
        var compartedToValue = (0, object_1.deepFind)(this.data, parameters[0]) || parameters[0];
        if (!Array.isArray(compartedToValue) && isNaN(compartedToValue) === false) {
            return (0, general_1.getSize)(value, validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules)) < compartedToValue;
        }
        if ((0, general_1.sameType)(value, compartedToValue) === false) {
            throw 'The fields under validation must be of the same type';
        }
        return (0, general_1.getSize)(value) < (0, general_1.getSize)(compartedToValue);
    };
    ;
    /**
     * Validate that an attribute is less than or equal another attribute.
     */
    validateAttributes.prototype.validateLte = function (value, parameters, attribute) {
        this.requireParameterCount(1, parameters, 'lte');
        if (typeof value !== 'number' && typeof value !== 'string' && typeof value !== 'object') {
            throw 'The field under validation must be a number, string, array or object';
        }
        var compartedToValue = (0, object_1.deepFind)(this.data, parameters[0]) || parameters[0];
        if (!Array.isArray(compartedToValue) && isNaN(compartedToValue) === false) {
            return (0, general_1.getSize)(value, validationRuleParser_1.default.hasRule(attribute, (0, general_1.getNumericRules)(), this.rules)) <= compartedToValue;
        }
        if ((0, general_1.sameType)(value, compartedToValue) === false) {
            throw 'The fields under validation must be of the same type';
        }
        return (0, general_1.getSize)(value) <= (0, general_1.getSize)(compartedToValue);
    };
    ;
    /**
     * Validate an attribute is contained within a list of values.
     */
    validateAttributes.prototype.validateIn = function (value, paramters) {
        if (Array.isArray(value)) {
            for (var index = 0; index < value.length; index++) {
                if (typeof value[index] !== 'number' && typeof value[index] !== 'string') {
                    return false;
                }
            }
            return value.filter(function (element) { return paramters.indexOf(element.toString()) === -1; }).length === 0;
        }
        ;
        if (typeof value !== 'number' && typeof value !== 'string') {
            return false;
        }
        return paramters.indexOf(value.toString()) !== -1;
    };
    ;
    /**
     * "Indicate" validation should pass if value is null
     *
     * Always returns true, just lets us put "nullable" in rules.
     */
    validateAttributes.prototype.validateNullable = function () {
        return true;
    };
    ;
    /**
     * Validate an attribute is not contained within a list of values.
     */
    validateAttributes.prototype.validateNotIn = function (value, parameters) {
        return !this.validateIn(value, parameters);
    };
    ;
    /**
     * Always returns true - this method will be used in conbination with other rules
     */
    validateAttributes.prototype.validateStrict = function () {
        return true;
    };
    ;
    /**
     * Validate that an attribute is a valid URL.
     */
    validateAttributes.prototype.validateUrl = function (value) {
        if (typeof value !== 'string') {
            return false;
        }
        var pattern = new RegExp('^(https?:\\/\\/)?' + // protocol
            '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' + // domain name
            '((\\d{1,3}\\.){3}\\d{1,3}))' + // OR ip (v4) address
            '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' + // port and path
            '(\\?[;&a-z\\d%_.~+=-]*)?' + // query string
            '(\\#[-a-z\\d_]*)?$', 'i'); // fragment locator
        return pattern.test(value);
    };
    ;
    /**
     *  Determine if a comparison passes between the given values.
     */
    validateAttributes.prototype.compareDates = function (value, parameter, operator, rule) {
        value = (0, date_1.toDate)(value);
        if (!value) {
            throw "Validation rule ".concat(rule, " requires the field under valation to be a date.");
        }
        var compartedToValue = (0, date_1.toDate)((0, object_1.deepFind)(this.data, parameter) || parameter);
        if (!compartedToValue) {
            throw "Validation rule ".concat(rule, " requires the parameter to be a date.");
        }
        return (0, general_1.compare)(value.getTime(), compartedToValue.getTime(), operator);
    };
    ;
    /**
     * Require a certain number of parameters to be present
     */
    validateAttributes.prototype.requireParameterCount = function (count, parameters, rule) {
        if (parameters.length < count) {
            throw "Validation rule ".concat(rule, " requires at least ").concat(count, " parameters.");
        }
    };
    ;
    return validateAttributes;
}());
;
exports.default = validateAttributes;

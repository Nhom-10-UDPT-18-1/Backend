'use strict';
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var validationData_1 = __importDefault(require("./validationData"));
var closureValidationRule_1 = __importDefault(require("../rules/closureValidationRule"));
var ruleContract_1 = __importDefault(require("../rules/ruleContract"));
var validationRuleParser = {
    /**
     * Convert rules to array
     */
    explodeRules: function (rules, data) {
        if (data === void 0) { data = {}; }
        var implicitAttributes = {};
        for (var key in rules) {
            if (key.indexOf('*') !== -1) {
                rules = this.explodeWildCardRules(rules, key, data, implicitAttributes);
                delete rules[key];
            }
            else if (rules.hasOwnProperty(key)) {
                rules[key] = this.explodeExplicitRules(rules[key]);
            }
        }
        return {
            rules: rules,
            implicitAttributes: implicitAttributes
        };
    },
    /**
     * Define a set of rules that apply to each element in an array attribute.
     */
    explodeWildCardRules: function (results, attribute, masterData, implicitAttributes) {
        var pattern = new RegExp('^' + attribute.replace(/\*/g, '[^.]*') + '$');
        var data = validationData_1.default.initializeAndGatherData(attribute, masterData);
        var rule = results[attribute];
        for (var key in data) {
            if (key.slice(0, attribute.length) === attribute || key.match(pattern) !== null) {
                if (Array.isArray(implicitAttributes[attribute])) {
                    implicitAttributes[attribute].push(key);
                }
                else {
                    implicitAttributes[attribute] = [key];
                }
                results = this.mergeRulesForAttribute(results, key, rule);
            }
        }
        return results;
    },
    /**
     * Merge additional rules into a given attribute.
     */
    mergeRulesForAttribute: function (results, attribute, rules) {
        var merge = this.explodeRules([rules]).rules[0];
        results[attribute] = __spreadArray(__spreadArray([], results[attribute] ? this.explodeExplicitRules(results[attribute]) : [], true), merge, true);
        return results;
    },
    /**
     * In case the rules specified by the user are a string seperated with '|' - convert them to an array
     */
    explodeExplicitRules: function (rules) {
        var _this = this;
        if (typeof rules === 'string') {
            return rules.split('|');
        }
        if (!Array.isArray(rules)) {
            return [this.prepareRule(rules)];
        }
        return rules.map(function (rule) { return _this.prepareRule(rule); });
    },
    /**
     * Prepare the given rule for the Validator.
     */
    prepareRule: function (rule) {
        if (typeof rule === 'function') {
            return new closureValidationRule_1.default(rule);
        }
        if (rule instanceof ruleContract_1.default) {
            return rule;
        }
        return rule.toString();
    },
    /**
     * Extract the rule name and parameters from a rule.
     */
    parse: function (rule) {
        if (rule instanceof ruleContract_1.default) {
            return [rule, []];
        }
        return this.parseStringRule(rule);
    },
    /**
     * Parse the parameters associated with a rule
     */
    parseStringRule: function (rule) {
        var _a;
        var parameters = [];
        var parameter;
        if (rule.indexOf(':') !== -1) {
            _a = rule.split(/:(.+)/), rule = _a[0], parameter = _a[1];
            parameters = this.parseParameters(rule, parameter);
        }
        return [rule, parameters];
    },
    /**
     * Parase marameters based on rule name
     */
    parseParameters: function (rule, parameter) {
        rule = rule.toLocaleLowerCase();
        if (['regex', 'not_regex', 'notregex'].indexOf(rule) !== -1) {
            return [parameter];
        }
        return parameter.split(',');
    },
    /**
     * Get a rule and its parameters for a given attribute.
     */
    getRule: function (attribute, searchRules, availableRules) {
        // The available rules are all the rules specified by the uer for example - 
        // { name: ['requied', 'string'], age: ['required', 'gt:10']}
        // A valid attribute in that case would be age
        if (!availableRules[attribute]) {
            return [];
        }
        // The search rule can be either a string or an array - lets say we want check if the 'gt' rule exists for 
        // the age attrtibute - in that case the serachRules will be equal to 'gt' - In case an array is used
        // the method will return the data for the first matched rule
        searchRules = Array.isArray(searchRules) ? searchRules : [searchRules];
        for (var i = 0; i < availableRules[attribute].length; i++) {
            var _a = this.parse(availableRules[attribute][i]), rule = _a[0], parameters = _a[1];
            if (searchRules.indexOf(rule) !== -1) {
                // return the rule and parameters for the first match
                return [rule, parameters];
            }
        }
        return [];
    },
    /**
     * Determine if the given attribute has a rule in the given set of available rules.
     */
    hasRule: function (attribute, searchRules, availableRules) {
        return this.getRule(attribute, searchRules, availableRules).length > 0;
    },
};
exports.default = validationRuleParser;

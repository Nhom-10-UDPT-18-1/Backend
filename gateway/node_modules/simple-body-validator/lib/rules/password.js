'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var formatMessages_1 = require("../utils/formatMessages");
var validator_1 = __importDefault(require("../validator"));
var ruleContract_1 = __importDefault(require("./ruleContract"));
var Password = /** @class */ (function (_super) {
    __extends(Password, _super);
    function Password() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * The minimum size of the password.
         */
        _this.minLength = 8;
        /**
         * The min amount of lower case letters required in the password
         */
        _this.minLowerCase = 0;
        /**
         * The min amount of uppercase letters required in the password
         */
        _this.minUpperCase = 0;
        /**
         * The min amount of letters required in the password
         */
        _this.minLetters = 0;
        /**
         * The min amount of letters required in the password
         */
        _this.minNumbers = 0;
        /**
         * The min amount of symbols required in the password
         */
        _this.minSymbols = 0;
        /**
         * Additional validation rules that should be merged into the default rules during validation.
         */
        _this.customRules = [];
        return _this;
    }
    /**
     * Create a new instance of the password class
     */
    Password.create = function () {
        return new Password();
    };
    /**
     * Set the minimum length of the password
     */
    Password.prototype.min = function (min) {
        this.minLength = min;
        return this;
    };
    /**
     * Set the min amount of letters required in the password
     */
    Password.prototype.letters = function (letters) {
        if (letters === void 0) { letters = 1; }
        this.minLetters = letters;
        return this;
    };
    /**
     * Set the min amount of upper and lower case letters required in the password
     */
    Password.prototype.mixedCase = function (upperCase, lowerCase) {
        if (upperCase === void 0) { upperCase = 1; }
        if (lowerCase === void 0) { lowerCase = 1; }
        this.minUpperCase = upperCase;
        this.minLowerCase = lowerCase;
        return this;
    };
    /**
     * Set the min amount of numbers required in the password
     */
    Password.prototype.numbers = function (numbers) {
        if (numbers === void 0) { numbers = 1; }
        this.minNumbers = numbers;
        return this;
    };
    ;
    /**
     * Set the min amount of symbols required in the password
     */
    Password.prototype.symbols = function (symbols) {
        if (symbols === void 0) { symbols = 1; }
        this.minSymbols = symbols;
        return this;
    };
    /**
     * Determine if the validation rule passes.
     */
    Password.prototype.passes = function (value, attribute) {
        var _a;
        var validator = new validator_1.default(this.data, (_a = {},
            _a[attribute] = __spreadArray(['string', "min:".concat(this.minLength)], this.customRules, true),
            _a), this.validator.customMessages).setLang(this.lang);
        if (!validator.validate()) {
            var errors = validator.errors().addErrorTypes().get(attribute);
            for (var key in errors) {
                this.validator.errors().add(attribute, errors[key]);
            }
        }
        if (typeof value !== 'string') {
            value = '';
        }
        var pattern;
        var formattedAttribute = (0, formatMessages_1.getDisplayableAttribute)(attribute);
        if (this.minLowerCase) {
            pattern = this.minLowerCase === 1 ? /\p{Ll}/u : new RegExp("(.*\\p{Ll}){".concat(this.minLowerCase, "}.*"), 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_lower_case',
                    message: this.trans("password.".concat(this.minLowerCase === 1 ? 'lower_case' : 'lower_cases'), {
                        attribute: formattedAttribute, amount: this.minLowerCase
                    })
                });
            }
        }
        if (this.minUpperCase) {
            pattern = this.minUpperCase === 1 ? /\p{Lu}/u : new RegExp("(.*\\p{Lu}){".concat(this.minUpperCase, "}.*"), 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_upper_case',
                    message: this.trans("password.".concat(this.minUpperCase === 1 ? 'upper_case' : 'upper_cases'), {
                        attribute: formattedAttribute, amount: this.minUpperCase
                    })
                });
            }
        }
        if (this.minLetters) {
            pattern = this.minLetters === 1 ? /\p{L}/u : new RegExp("(.*\\p{L}){".concat(this.minLetters, "}.*"), 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_letters',
                    message: this.trans("password.".concat(this.minLetters === 1 ? 'letter' : 'letters'), {
                        attribute: formattedAttribute, amount: this.minLetters
                    })
                });
            }
        }
        if (this.minNumbers) {
            pattern = this.minNumbers === 1 ? /\p{N}/u : new RegExp("(.*\\p{N}){".concat(this.minNumbers, "}.*"), 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_numbers',
                    message: this.trans("password.".concat(this.minNumbers === 1 ? 'number' : 'numbers'), {
                        attribute: formattedAttribute, amount: this.minNumbers
                    })
                });
            }
        }
        if (this.minSymbols) {
            pattern = this.minSymbols === 1 ? /\p{Z}|\p{S}|\p{P}/u : new RegExp("(.*(\\p{Z}|\\p{S}|\\p{P})){".concat(this.minSymbols, "}.*"), 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_symbols',
                    message: this.trans("password.".concat(this.minSymbols === 1 ? 'symbol' : 'symbols'), {
                        attribute: formattedAttribute, amount: this.minSymbols
                    })
                });
            }
        }
        if (this.validator.errors().has(attribute)) {
            return false;
        }
        return true;
    };
    /**
     * Specify additional validation rules that should be merged with the default rules during validation.
     */
    Password.prototype.rules = function (rules) {
        this.customRules = rules;
        return this;
    };
    /**
     * Get all the validation error messages related to the password
     */
    Password.prototype.getMessage = function () {
        return {};
    };
    /**
     * Set the validator instance used to validate the password
     */
    Password.prototype.setValidator = function (validator) {
        this.validator = validator;
        return this;
    };
    /**
     * Set the default callback to be used for determining a password's default rules.
     */
    Password.setDefault = function (callback) {
        if (callback === void 0) { callback = null; }
        if (callback instanceof Password) {
            this.defaultCallback = callback;
            return;
        }
        if (typeof callback !== 'function') {
            throw 'The given callback should be callable';
        }
        this.defaultCallback = callback;
    };
    /**
     * Get the default configuration of the password rule.
     */
    Password.default = function () {
        var password = typeof this.defaultCallback === 'function' ? this.defaultCallback() : this.defaultCallback;
        return password instanceof ruleContract_1.default ? password : Password.create().min(8);
    };
    return Password;
}(ruleContract_1.default));
;
exports.default = Password;

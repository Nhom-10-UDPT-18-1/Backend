'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDisplayableAttribute = exports.toSnakeCase = exports.makeReplacements = exports.getMessage = void 0;
var general_1 = require("./general");
var replaceAttributes_1 = __importDefault(require("../validators/replaceAttributes"));
var build_1 = require("./build");
var lang_1 = __importDefault(require("../lang"));
/**
 * Get the message type based on the value. The message type is used essentially for size rules
 */
function getMesageType(value, hasNumericRule) {
    if (hasNumericRule === void 0) { hasNumericRule = false; }
    if (typeof value === 'number' || typeof value === 'undefined' || (isNaN(value) === false && hasNumericRule === true)) {
        return 'number';
    }
    if (Array.isArray(value)) {
        return 'array';
    }
    return typeof value;
}
;
/**
 * Get the inline message for a rule if exists
 */
function getFromLocalObject(attribute, rule, customMessages) {
    var key = "".concat(attribute, ".").concat(rule);
    if (typeof customMessages[key] !== 'undefined') {
        return customMessages[key];
    }
    else if (typeof customMessages[rule] !== 'undefined') {
        return customMessages[rule];
    }
    for (var messageKey in customMessages) {
        if (messageKey.indexOf('*') !== -1) {
            var pattern = new RegExp('^' + messageKey.replace(/\*/g, '[^\.]*'));
            if (key.match(pattern)) {
                return customMessages[messageKey];
            }
        }
    }
    ;
    return null;
}
;
/**
 * Get the validation message for an attribute and rule.
 */
function getMessage(attribute, rule, value, customMessages, hasNumericRule, lang) {
    // check if error exists inside the custom message object provided by the user
    var inlineMessage = getFromLocalObject(attribute, rule, customMessages);
    if (inlineMessage) {
        return inlineMessage;
    }
    var validationMessages = lang_1.default.get(lang);
    // check if rule has sizes such as min, max, between ...
    // and get message from local object
    if ((0, general_1.isSizeRule)(rule) === true) {
        return validationMessages[rule][getMesageType(value, hasNumericRule)];
    }
    // get message from local object
    return validationMessages[rule] || '';
}
exports.getMessage = getMessage;
;
/**
 * Replace all error message place-holders with actual values.
 */
function makeReplacements(message, attribute, rule, parameters, data, hasNumericRule) {
    if (data === void 0) { data = {}; }
    if (hasNumericRule === void 0) { hasNumericRule = false; }
    message = message.replace(':attribute', getDisplayableAttribute(attribute));
    var methodName = "replace".concat((0, build_1.builValidationdMethodName)(rule));
    if (typeof replaceAttributes_1.default[methodName] === 'function') {
        message = replaceAttributes_1.default[methodName](message, parameters, data, hasNumericRule);
    }
    return message;
}
exports.makeReplacements = makeReplacements;
/**
 * Convert a string to snake case.
 */
function toSnakeCase(string) {
    return string
        .split(/ |\B(?=[A-Z])/)
        .map(function (word) { return word.toLowerCase(); })
        .join('_');
}
exports.toSnakeCase = toSnakeCase;
/**
 * Get the displayable name of the attribute.
 */
function getDisplayableAttribute(attribute) {
    return toSnakeCase(attribute).replace(/_/g, ' ').trim();
}
exports.getDisplayableAttribute = getDisplayableAttribute;

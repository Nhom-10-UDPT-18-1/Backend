'use strict';
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeDeep = exports.isObject = exports.dotify = exports.deepSet = exports.deepFind = void 0;
var general_1 = require("./general");
/**
 * Get value at path of object. If the resolved value is undifined, the returned result will be undefined
 */
function deepFind(obj, path) {
    var paths = path.split('.');
    for (var i = 0; i < paths.length; i++) {
        if (typeof obj[paths[i]] === 'undefined') {
            return undefined;
        }
        obj = obj[paths[i]];
    }
    return obj;
}
exports.deepFind = deepFind;
;
/**
 * Set value at path of object.
 */
function deepSet(target, path, value) {
    var paths = typeof path === 'string' ? path.split('.') : path;
    var segment = paths.shift();
    if (segment === '*') {
        target = Array.isArray(target) ? target : [];
        if (paths.length > 0) {
            target.forEach(function (inner) { return deepSet(inner, __spreadArray([], paths, true), value); });
        }
        else {
            for (var i = 0; i < target.length; i++) {
                target[i] = value;
            }
        }
    }
    else if (paths.length > 0) {
        if (typeof target[segment] !== 'object') {
            target[segment] = {};
        }
        deepSet(target[segment], paths, value);
    }
    else {
        if (typeof target !== 'object' || target === null) {
            target = {};
        }
        target[segment] = value;
    }
}
exports.deepSet = deepSet;
;
/**
 * Flatten a multi-dimensional associative array with dots.
 */
function dotify(obj, ignoreRulesArray) {
    if (ignoreRulesArray === void 0) { ignoreRulesArray = false; }
    var res = {};
    (function recurse(obj, current) {
        if (current === void 0) { current = ''; }
        for (var key in obj) {
            var value = obj[key];
            var newKey = (current ? "".concat(current, ".").concat(key) : key);
            if (value && typeof value === 'object' && !(0, general_1.isRule)(value) && !(value instanceof Date)) {
                if (ignoreRulesArray === true && Array.isArray(value) && (0, general_1.isArrayOfRules)(value)) {
                    res[newKey] = value;
                }
                else {
                    recurse(value, newKey);
                }
            }
            else {
                res[newKey] = value;
            }
        }
    })(obj);
    return res;
}
exports.dotify = dotify;
;
/**
 * Check if the value is an object
 */
function isObject(value) {
    return value && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
;
/**
 * Deeply merge nested objects
 */
function mergeDeep(target, source) {
    var _a, _b;
    var output = Object.assign({}, target);
    if (!isObject(target) || !isObject(source)) {
        return output;
    }
    for (var key in source) {
        if (isObject(source[key])) {
            if (!target[key]) {
                Object.assign(output, (_a = {}, _a[key] = source[key], _a));
            }
            else {
                output[key] = mergeDeep(target[key], source[key]);
            }
        }
        else {
            Object.assign(output, (_b = {}, _b[key] = source[key], _b));
        }
    }
    return output;
}
exports.mergeDeep = mergeDeep;
